import Sprockell
prog :: [Instruction]
prog = [
    Load (ImmValue 0) regA,
    WriteInstr regA (DirAddr 0),
    ReadInstr (IndAddr regSprID),
    Receive regA,
    Compute Equal regSprID reg0 regB,
    Branch regB (Rel 4),
    Compute NEq regA regSprID regB,
    Branch regB (Ind regA),
    Jump (Rel (-6)),
    Load (ImmValue 1 ) regA,
    Store regA (DirAddr 0),
    Load (ImmValue 5) regA,
    Store regA (DirAddr 1),
    Load (ImmValue 0) regA,
    Store regA (DirAddr 2),
    Load (DirAddr 0) regA,
    Load (ImmValue 0) regE,
    Compute Equal regE regA regA,
    Branch regA (Rel 4),
    Load (ImmValue 0) regA,
    Store regA (DirAddr 1),
    Jump (Rel 3 ),
    Load (ImmValue 2) regA,
    Store regA (DirAddr 1),
    Load (DirAddr 1) regA,
    WriteInstr regA numberIO,
    Load (DirAddr 0) regA,
    Compute Equal regA reg0 regA,
    Load (ImmValue 0) regE,
    Compute Equal regE regA regA,
    Branch regA (Rel 4),
    Load (ImmValue 15) regA,
    Store regA (DirAddr 2),
    Jump (Rel 3 ),
    Load (ImmValue 2) regA,
    Store regA (DirAddr 2),
    Load (DirAddr 2) regA,
    WriteInstr regA numberIO,
    Load (DirAddr 1) regA,
    Push regA,
    Load (DirAddr 2) regA,
    Pop regB,
    Compute Equal regB regA regA,
    Load (ImmValue 0) regE,
    Compute Equal regE regA regA,
    Branch regA (Rel 6),
    Load (ImmValue 100) regA,
    Store regA (DirAddr 1),
    Load (ImmValue 100) regA,
    Store regA (DirAddr 2),
    Jump (Rel 1 ),
    Load (DirAddr 1) regA,
    WriteInstr regA numberIO,
    Load (DirAddr 2) regA,
    WriteInstr regA numberIO,
    Compute Add reg0 regPC regA,
    Compute Equal regSprID reg0 regB,
    Branch regB (Rel 2),
    EndProg,
    EndProg]
main = run [prog]
